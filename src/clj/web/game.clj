(ns web.game
  (:require
    ;; external
    [cheshire.core :as json]
    [crypto.password.bcrypt :as bcrypt]
    [clj-time.core :as t]
    ;; internal
    [web.ws :as ws]
    [web.lobby :refer [old-states already-in-game? spectator? handle-lobby-watch] :as lobby]
    [web.stats :as stats]
    [game.main :as main]
    [game.core.diffs :refer [public-diffs public-states]]
    [game.core :as core]
    [jinteki.utils :refer [side-from-str]]))

(defn send-state-diffs!
  "Sends diffs generated by public-diffs to all connected clients."
  [{:keys [gameid players spectators]}
   {:keys [runner-diff corp-diff spect-diff]}]
  (doseq [{:keys [ws-id side]} players]
    (ws/broadcast-to! [ws-id] :netrunner/diff (json/generate-string {:gameid gameid
                                                                     :diff (if (= side "Corp")
                                                                              corp-diff
                                                                              runner-diff)})))
  (ws/broadcast-to! (map #(:ws-id %) spectators)
                    :netrunner/diff
                    (json/generate-string {:gameid gameid
                                           :diff spect-diff})))

(defn send-state!
  "Sends full states generated by public-states to either the client specified or all connected clients."
  ([event
    {:keys [players]}
    {:keys [runner-state corp-state spect-state]}
    ws-id]
   (let [player (some #(= (:ws-id %) ws-id) players)]
     (ws/broadcast-to! [ws-id] event (json/generate-string (if player
                                                              (if (= (:side player) "Corp")
                                                                corp-state
                                                                runner-state)
                                                              spect-state)))))

  ([event
    {:keys [players spectators]}
    {:keys [runner-state corp-state spect-state]}]
   (doseq [{:keys [ws-id side]} players]
     (ws/broadcast-to! [ws-id] event (json/generate-string (if (= side "Corp")
                                                              corp-state
                                                              runner-state))))
   (ws/broadcast-to! (map #(:ws-id %) spectators) event (json/generate-string spect-state))))

(defn swap-and-send-diffs!
  "Updates the old-states atom with the new game state, then sends a :netrunner/diff
  message to game clients."
  [{:keys [gameid state] :as game}]
  (when (and state @state)
    (let [old-state (get @old-states gameid)
          diffs (public-diffs old-state state)]
      (swap! state update :history conj (:hist-diff diffs))
      (swap! old-states assoc gameid @state)
      (send-state-diffs! game diffs))))

(defn- active-game?
  [gameid-str client-id]
  (if (nil? gameid-str)
    false
    (try
      (let [gameid (java.util.UUID/fromString gameid-str)
            game-from-gameid (lobby/game-for-id gameid)
            game-from-clientid (lobby/game-for-client client-id)]
        (and game-from-clientid
             game-from-gameid
             (= (:gameid game-from-clientid) (:gameid game-from-gameid))))
      (catch Exception e false))))

(defn- is-starter-deck?
  [player]
  (let [id (get-in player [:deck :identity :title])
        card-cnt (reduce + (map :qty (get-in player [:deck :cards])))]
    (or (and (= id "The Syndicate: Profit over Principle")
             (= card-cnt 34))
        (and (= id "The Catalyst: Convention Breaker")
             (= card-cnt 30)))))

(defn- check-for-starter-decks
  "Starter Decks can require 6 or 7 agenda points"
  [game]
  (if (and (= (:format game) "system-gateway")
           (every? is-starter-deck? (:players game)))
    (do
      (swap! (:state game) assoc-in [:runner :agenda-point-req] 6)
      (swap! (:state game) assoc-in [:corp :agenda-point-req] 6)
      game)
    game))

(defmethod ws/-msg-handler :netrunner/start
  [{{db :system/db} :ring-req
    client-id :client-id}]
  (when-let [{:keys [players gameid started] :as game} (lobby/game-for-client client-id)]
    (when (and (lobby/first-player? client-id game)
               (not started))
      (let [strip-deck (fn [player] (-> player
                                        (update-in [:deck] #(select-keys % [:_id :identity :name :hash]))
                                        (update-in [:deck :identity] #(select-keys % [:title :faction]))))
            stripped-players (mapv strip-deck players)
            game-state (core/init-game game)
            _ (swap! game-state assoc :history [(:hist-state (public-states game-state))])
            game (-> game
                     (assoc :started true
                            :original-players stripped-players
                            :ending-players stripped-players
                            :start-date (java.util.Date.)
                            :last-update (t/now)
                            :state game-state)
                     (check-for-starter-decks)
                     (update :players #(mapv strip-deck %)))]
        (stats/game-started db game)
        (lobby/refresh-lobby gameid game)
        (swap! old-states assoc gameid @(:state game))
        (send-state! :netrunner/start game (public-states (:state game)))))))

(defmethod ws/-msg-handler :netrunner/leave
  [{{db :system/db
     {:keys [username]} :user} :ring-req
    client-id :client-id}]
  (let [{:keys [started gameid state]} (lobby/game-for-client client-id)]
    (when (and started state)
      (lobby/remove-user db client-id gameid)
      (when (lobby/game-for-id gameid)
        ; The game will not exist if this is the last player to leave.
        (main/handle-notification state (str username " has left the game."))
        (swap-and-send-diffs! (lobby/game-for-id gameid))))))

(defmethod ws/-msg-handler :netrunner/rejoin
  [{{{:keys [_id] :as user} :user} :ring-req
    client-id                      :client-id
    {:keys [gameid]}               :?data}]
  (let [{:keys [original-players started players state] :as game} (lobby/game-for-id gameid)
        original-player (some #(if (= _id (get-in % [:user :_id])) % nil) original-players)]
    (when (and started
               (< (count (filter #(not= _id (get-in % [:user :_id])) players)) 2)
               original-player)
      (let [side (keyword (str (.toLowerCase (:side original-player)) "-state"))]
        (ws/broadcast-to! [client-id] :games/diff {:diff {:update {gameid (lobby/game-lobby-view gameid game)}}})
        (ws/broadcast-to! [client-id] :lobby/select {:gameid gameid
                                                     :started started
                                                     :state (json/generate-string (side (public-states (:state game))))}) ;side works here because user cannot rejoin as a spectator
        (lobby/join-game user client-id gameid "Any Side")
        (main/handle-rejoin state user)
        (swap-and-send-diffs! (lobby/game-for-id gameid))))))

(defmethod ws/-msg-handler :netrunner/concede
  [{client-id            :client-id
    {:keys [gameid-str]} :?data}]
  (when (active-game? gameid-str client-id)
    (let [gameid (java.util.UUID/fromString gameid-str)
          {:keys [players state] :as game} (lobby/game-for-id gameid)
          side (some #(when (= client-id (:ws-id %)) (:side %)) players)]
      (when (lobby/player? client-id game)
        (main/handle-concede state (side-from-str side))
        (swap-and-send-diffs! game)))))

(defmethod ws/-msg-handler :netrunner/mute-spectators
  [{{{:keys [username]} :user}      :ring-req
    client-id                       :client-id
    {:keys [gameid-str mute-state]} :?data}]
  (when (active-game? gameid-str client-id)
    (let [gameid (java.util.UUID/fromString gameid-str)
          {:keys [state] :as game} (lobby/game-for-id gameid)
          message (if mute-state "muted" "unmuted")]
      (when (lobby/player? client-id game)
        (lobby/refresh-lobby-assoc-in gameid [:mute-spectators] mute-state)
        (main/handle-notification state (str username " " message " spectators."))
        (swap-and-send-diffs! game)))))

(defmethod ws/-msg-handler :netrunner/action
  [{{user :user} :ring-req
    client-id                           :client-id
    {:keys [gameid-str command args]} :?data}]
  (when (active-game? gameid-str client-id)
    (try
      (let [gameid (java.util.UUID/fromString gameid-str)
            {:keys [players state] :as game} (lobby/game-for-id gameid)
            side (some #(when (= client-id (:ws-id %)) (:side %)) players)
            spectator (spectator? client-id game)]
        (if (and state side)
            (let [old-state @state]
              (try
                (do (main/handle-action user command state (side-from-str side) args)
                    (lobby/refresh-lobby-assoc-in gameid [:last-update] (t/now))
                    (swap-and-send-diffs! game))
                (catch Exception e
                  (reset! state old-state)
                  (throw e))))
            (when-not spectator
              (println "handle-game-action unknown state or side")
              (println "\tGameID:" gameid)
              (println "\tGameID by ClientID:" (:gameid (lobby/game-for-client client-id)))
              (println "\tClientID:" client-id)
              (println "\tSide:" side)
              (println "\tPlayers:" (map #(select-keys % [:ws-id :side]) players))
              (println "\tSpectators" (map #(select-keys % [:ws-id]) (:spectators game)))
              (println "\tCommand:" command)
              (println "\tArgs:" args "\n"))))
      (catch Exception e
        (ws/broadcast-to! [client-id] :netrunner/error nil)
        (println "Caught exception")
        (println (str "Exception Data: " (or (ex-data e) (.getMessage e))))
        (println (str "Command: " command))
        (println (str "GameId: " gameid-str))))))

(defmethod ws/-msg-handler :netrunner/resync
  [{{user :user} :ring-req
    client-id    :client-id
    {:keys [gameid-str]} :?data}]
  (when (active-game? gameid-str client-id)
    (let [gameid (java.util.UUID/fromString gameid-str)
          {:keys [players state] :as game} (lobby/game-for-id gameid)]
      (if state
          (send-state! :netrunner/state game (public-states (:state game)) client-id)
          (do (println "resync request unknown state")
              (println "\tGameID:" gameid)
              (println "\tGameID by ClientID:" (:gameid (lobby/game-for-client client-id)))
              (println "\tClientID:" client-id)
              (println "\tPlayers:" (map #(select-keys % [:ws-id :side]) players))
              (println "\tSpectators" (map #(select-keys % [:ws-id]) (:spectators game))))))))

(defmethod ws/-msg-handler :lobby/watch
  ;; Handles a watch command when a game has started.
  [{{db :system/db
     {:keys [username] :as user} :user} :ring-req
    client-id :client-id
    {:keys [gameid password]} :?data
    reply-fn :?reply-fn :as arg}]
  (handle-lobby-watch arg)
  (if-let [{game-password :password state :state started :started :as game}
           (lobby/game-for-id gameid)]
    (when (and user game (lobby/allowed-in-game db game user) state @state)
      (if-not started
        false ; don't handle this message, let lobby/handle-game-watch.
        (if (and (not (already-in-game? user game))
                 (or (empty? game-password)
                     (bcrypt/check password game-password)))
          (let [{:keys [spect-state]} (public-states state)]
            ;; Add as a spectator, inform the client that this is the active game,
            ;; Send existing state to spectator
            ;; add a chat message, then send diff state to all players.
            (ws/broadcast-to! [client-id] :lobby/select {:gameid gameid
                                                         :started started
                                                         :state (json/generate-string spect-state)})
            (ws/broadcast-to! [client-id] :games/diff {:diff {:update {gameid (lobby/game-lobby-view gameid game)}}})
            (lobby/spectate-game user client-id gameid)
            (main/handle-notification state (str username " joined the game as a spectator."))
            (swap-and-send-diffs! (lobby/game-for-id gameid))
            (when reply-fn
              (reply-fn 200)))
          (when reply-fn
            (reply-fn 403)))))
    (when reply-fn
      (reply-fn 404))))

(defmethod ws/-msg-handler :netrunner/say
  [{{user :user} :ring-req
    client-id :client-id
    {:keys [gameid-str msg]} :?data}]
  (when (active-game? gameid-str client-id)
    (let [gameid (java.util.UUID/fromString gameid-str)
          {:keys [state mute-spectators] :as game} (lobby/game-for-id gameid)
          {:keys [side]} (lobby/player? client-id game)]
      (if (and state side user)
        (do (main/handle-say state (jinteki.utils/side-from-str side) user msg)
            (swap-and-send-diffs! game))
        (when (and (lobby/spectator? client-id game) (not mute-spectators))
          (main/handle-say state :spectator user msg)
          (lobby/refresh-lobby-assoc-in gameid [:last-update] (t/now))
          (try
            (swap-and-send-diffs! game)
            (catch Exception ex
              (println (str "handle-game-say exception:" (.getMessage ex) "\n")))))))))

(defmethod ws/-msg-handler :netrunner/typing
  [{client-id :client-id
    {:keys [gameid-str typing]} :?data}]
  (when (active-game? gameid-str client-id)
    (let [gameid (java.util.UUID/fromString gameid-str)
          {:keys [state] :as game} (lobby/game-for-id gameid)
          {:keys [side user]} (lobby/player? client-id game)]
      (when (and state side user)
        (main/handle-typing state (jinteki.utils/side-from-str side) user typing)
        (try
          (swap-and-send-diffs! game)
          (catch Exception ex
            (println (str "handle-game-typing exception:" (.getMessage ex) "\n"))))))))

(defmethod ws/-msg-handler :chsk/uidport-close
  [{{db :system/db
     {:keys [username]} :user} :ring-req
    client-id :client-id}]
  (when-let [{:keys [gameid state]} (lobby/game-for-client client-id)]
    (lobby/remove-user db client-id gameid)
    (when-let [game (lobby/game-for-id gameid)]
      ; The game will not exist if this is the last player to leave.
      (main/handle-notification state (str username " has disconnected."))
      (swap-and-send-diffs! game))))
